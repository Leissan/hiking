{"ast":null,"code":"const tab = 9;\n/* `\\t` */\n\nconst space = 32;\n/* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\n\nexport function trimLines(value) {\n  const source = String(value);\n  const search = /\\r?\\n|\\r/g;\n  let match = search.exec(source);\n  let last = 0;\n  /** @type {Array<string>} */\n\n  const lines = [];\n\n  while (match) {\n    lines.push(trimLine(source.slice(last, match.index), last > 0, true), match[0]);\n    last = match.index + match[0].length;\n    match = search.exec(source);\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false));\n  return lines.join('');\n}\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\n\nfunction trimLine(value, start, end) {\n  let startIndex = 0;\n  let endIndex = value.length;\n\n  if (start) {\n    let code = value.codePointAt(startIndex);\n\n    while (code === tab || code === space) {\n      startIndex++;\n      code = value.codePointAt(startIndex);\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1);\n\n    while (code === tab || code === space) {\n      endIndex--;\n      code = value.codePointAt(endIndex - 1);\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : '';\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/trim-lines/index.js"],"names":["tab","space","trimLines","value","source","String","search","match","exec","last","lines","push","trimLine","slice","index","length","join","start","end","startIndex","endIndex","code","codePointAt"],"mappings":"AAAA,MAAMA,GAAG,GAAG,CAAZ;AAAc;;AACd,MAAMC,KAAK,GAAG,EAAd;AAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAC/B,QAAMC,MAAM,GAAGC,MAAM,CAACF,KAAD,CAArB;AACA,QAAMG,MAAM,GAAG,WAAf;AACA,MAAIC,KAAK,GAAGD,MAAM,CAACE,IAAP,CAAYJ,MAAZ,CAAZ;AACA,MAAIK,IAAI,GAAG,CAAX;AACA;;AACA,QAAMC,KAAK,GAAG,EAAd;;AAEA,SAAOH,KAAP,EAAc;AACZG,IAAAA,KAAK,CAACC,IAAN,CACEC,QAAQ,CAACR,MAAM,CAACS,KAAP,CAAaJ,IAAb,EAAmBF,KAAK,CAACO,KAAzB,CAAD,EAAkCL,IAAI,GAAG,CAAzC,EAA4C,IAA5C,CADV,EAEEF,KAAK,CAAC,CAAD,CAFP;AAKAE,IAAAA,IAAI,GAAGF,KAAK,CAACO,KAAN,GAAcP,KAAK,CAAC,CAAD,CAAL,CAASQ,MAA9B;AACAR,IAAAA,KAAK,GAAGD,MAAM,CAACE,IAAP,CAAYJ,MAAZ,CAAR;AACD;;AAEDM,EAAAA,KAAK,CAACC,IAAN,CAAWC,QAAQ,CAACR,MAAM,CAACS,KAAP,CAAaJ,IAAb,CAAD,EAAqBA,IAAI,GAAG,CAA5B,EAA+B,KAA/B,CAAnB;AAEA,SAAOC,KAAK,CAACM,IAAN,CAAW,EAAX,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASJ,QAAT,CAAkBT,KAAlB,EAAyBc,KAAzB,EAAgCC,GAAhC,EAAqC;AACnC,MAAIC,UAAU,GAAG,CAAjB;AACA,MAAIC,QAAQ,GAAGjB,KAAK,CAACY,MAArB;;AAEA,MAAIE,KAAJ,EAAW;AACT,QAAII,IAAI,GAAGlB,KAAK,CAACmB,WAAN,CAAkBH,UAAlB,CAAX;;AAEA,WAAOE,IAAI,KAAKrB,GAAT,IAAgBqB,IAAI,KAAKpB,KAAhC,EAAuC;AACrCkB,MAAAA,UAAU;AACVE,MAAAA,IAAI,GAAGlB,KAAK,CAACmB,WAAN,CAAkBH,UAAlB,CAAP;AACD;AACF;;AAED,MAAID,GAAJ,EAAS;AACP,QAAIG,IAAI,GAAGlB,KAAK,CAACmB,WAAN,CAAkBF,QAAQ,GAAG,CAA7B,CAAX;;AAEA,WAAOC,IAAI,KAAKrB,GAAT,IAAgBqB,IAAI,KAAKpB,KAAhC,EAAuC;AACrCmB,MAAAA,QAAQ;AACRC,MAAAA,IAAI,GAAGlB,KAAK,CAACmB,WAAN,CAAkBF,QAAQ,GAAG,CAA7B,CAAP;AACD;AACF;;AAED,SAAOA,QAAQ,GAAGD,UAAX,GAAwBhB,KAAK,CAACU,KAAN,CAAYM,UAAZ,EAAwBC,QAAxB,CAAxB,GAA4D,EAAnE;AACD","sourcesContent":["const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n"]},"metadata":{},"sourceType":"module"}