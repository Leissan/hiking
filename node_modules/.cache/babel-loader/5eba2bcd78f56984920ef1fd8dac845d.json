{"ast":null,"code":"/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */\n// To do: next major: always return array.\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType;\n  let suffix = ']';\n\n  if (subtype === 'collapsed') {\n    suffix += '[]';\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']';\n  }\n\n  if (node.type === 'imageReference') {\n    return {\n      type: 'text',\n      value: '![' + node.alt + suffix\n    };\n  }\n\n  const contents = state.all(node);\n  const head = contents[0];\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value;\n  } else {\n    contents.unshift({\n      type: 'text',\n      value: '['\n    });\n  }\n\n  const tail = contents[contents.length - 1];\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix;\n  } else {\n    contents.push({\n      type: 'text',\n      value: suffix\n    });\n  }\n\n  return contents;\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-to-hast/lib/revert.js"],"names":["revert","state","node","subtype","referenceType","suffix","label","identifier","type","value","alt","contents","all","head","unshift","tail","length","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,KAAhB,EAAuBC,IAAvB,EAA6B;AAClC,QAAMC,OAAO,GAAGD,IAAI,CAACE,aAArB;AACA,MAAIC,MAAM,GAAG,GAAb;;AAEA,MAAIF,OAAO,KAAK,WAAhB,EAA6B;AAC3BE,IAAAA,MAAM,IAAI,IAAV;AACD,GAFD,MAEO,IAAIF,OAAO,KAAK,MAAhB,EAAwB;AAC7BE,IAAAA,MAAM,IAAI,OAAOH,IAAI,CAACI,KAAL,IAAcJ,IAAI,CAACK,UAA1B,IAAwC,GAAlD;AACD;;AAED,MAAIL,IAAI,CAACM,IAAL,KAAc,gBAAlB,EAAoC;AAClC,WAAO;AAACA,MAAAA,IAAI,EAAE,MAAP;AAAeC,MAAAA,KAAK,EAAE,OAAOP,IAAI,CAACQ,GAAZ,GAAkBL;AAAxC,KAAP;AACD;;AAED,QAAMM,QAAQ,GAAGV,KAAK,CAACW,GAAN,CAAUV,IAAV,CAAjB;AACA,QAAMW,IAAI,GAAGF,QAAQ,CAAC,CAAD,CAArB;;AAEA,MAAIE,IAAI,IAAIA,IAAI,CAACL,IAAL,KAAc,MAA1B,EAAkC;AAChCK,IAAAA,IAAI,CAACJ,KAAL,GAAa,MAAMI,IAAI,CAACJ,KAAxB;AACD,GAFD,MAEO;AACLE,IAAAA,QAAQ,CAACG,OAAT,CAAiB;AAACN,MAAAA,IAAI,EAAE,MAAP;AAAeC,MAAAA,KAAK,EAAE;AAAtB,KAAjB;AACD;;AAED,QAAMM,IAAI,GAAGJ,QAAQ,CAACA,QAAQ,CAACK,MAAT,GAAkB,CAAnB,CAArB;;AAEA,MAAID,IAAI,IAAIA,IAAI,CAACP,IAAL,KAAc,MAA1B,EAAkC;AAChCO,IAAAA,IAAI,CAACN,KAAL,IAAcJ,MAAd;AACD,GAFD,MAEO;AACLM,IAAAA,QAAQ,CAACM,IAAT,CAAc;AAACT,MAAAA,IAAI,EAAE,MAAP;AAAeC,MAAAA,KAAK,EAAEJ;AAAtB,KAAd;AACD;;AAED,SAAOM,QAAP;AACD","sourcesContent":["/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Reference} Reference\n * @typedef {import('mdast').Root} Root\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Reference>} References\n */\n\n// To do: next major: always return array.\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {References} node\n *   Reference node (image, link).\n * @returns {ElementContent | Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return {type: 'text', value: '![' + node.alt + suffix}\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n"]},"metadata":{},"sourceType":"module"}