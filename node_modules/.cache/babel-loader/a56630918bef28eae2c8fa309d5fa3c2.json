{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node);\n  const loose = parent ? listLoose(parent) : listItemLoose(node);\n  /** @type {Properties} */\n\n  const properties = {};\n  /** @type {Array<ElementContent>} */\n\n  const children = [];\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0];\n    /** @type {Element} */\n\n    let paragraph;\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head;\n    } else {\n      paragraph = {\n        type: 'element',\n        tagName: 'p',\n        properties: {},\n        children: []\n      };\n      results.unshift(paragraph);\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({\n        type: 'text',\n        value: ' '\n      });\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {\n        type: 'checkbox',\n        checked: node.checked,\n        disabled: true\n      },\n      children: []\n    }); // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n\n    properties.className = ['task-list-item'];\n  }\n\n  let index = -1;\n\n  while (++index < results.length) {\n    const child = results[index]; // Add eols before nodes, except if this is a loose, first paragraph.\n\n    if (loose || index !== 0 || child.type !== 'element' || child.tagName !== 'p') {\n      children.push({\n        type: 'text',\n        value: '\\n'\n      });\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children);\n    } else {\n      children.push(child);\n    }\n  }\n\n  const tail = results[results.length - 1]; // Add a final eol.\n\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n  /** @type {Element} */\n\n\n  const result = {\n    type: 'element',\n    tagName: 'li',\n    properties,\n    children\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\n\nfunction listLoose(node) {\n  let loose = false;\n\n  if (node.type === 'list') {\n    loose = node.spread || false;\n    const children = node.children;\n    let index = -1;\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index]);\n    }\n  }\n\n  return loose;\n}\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\n\n\nfunction listItemLoose(node) {\n  const spread = node.spread;\n  return spread === undefined || spread === null ? node.children.length > 1 : spread;\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-to-hast/lib/handlers/list-item.js"],"names":["listItem","state","node","parent","results","all","loose","listLoose","listItemLoose","properties","children","checked","head","paragraph","type","tagName","unshift","length","value","disabled","className","index","child","push","tail","result","patch","applyData","spread","undefined"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === undefined || spread === null\n    ? node.children.length > 1\n    : spread\n}\n"]},"metadata":{},"sourceType":"module"}