{"ast":null,"code":"/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\nimport { visit } from 'unist-util-visit';\nconst own = {}.hasOwnProperty;\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\n\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null);\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node');\n  }\n\n  visit(tree, 'definition', definition => {\n    const id = clean(definition.identifier);\n\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition;\n    }\n  });\n  return definition;\n  /** @type {GetDefinition} */\n\n  function definition(identifier) {\n    const id = clean(identifier); // To do: next major: return `undefined` when not found.\n\n    return id && own.call(cache, id) ? cache[id] : null;\n  }\n}\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\n\nfunction clean(value) {\n  return String(value || '').toUpperCase();\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-definitions/lib/index.js"],"names":["visit","own","hasOwnProperty","definitions","tree","cache","Object","create","type","Error","definition","id","clean","identifier","call","value","String","toUpperCase"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,KAAR,QAAoB,kBAApB;AAEA,MAAMC,GAAG,GAAG,GAAGC,cAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2B;AAChC;AACA,QAAMC,KAAK,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAd;;AAEA,MAAI,CAACH,IAAD,IAAS,CAACA,IAAI,CAACI,IAAnB,EAAyB;AACvB,UAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;;AAEDT,EAAAA,KAAK,CAACI,IAAD,EAAO,YAAP,EAAsBM,UAAD,IAAgB;AACxC,UAAMC,EAAE,GAAGC,KAAK,CAACF,UAAU,CAACG,UAAZ,CAAhB;;AACA,QAAIF,EAAE,IAAI,CAACV,GAAG,CAACa,IAAJ,CAAST,KAAT,EAAgBM,EAAhB,CAAX,EAAgC;AAC9BN,MAAAA,KAAK,CAACM,EAAD,CAAL,GAAYD,UAAZ;AACD;AACF,GALI,CAAL;AAOA,SAAOA,UAAP;AAEA;;AACA,WAASA,UAAT,CAAoBG,UAApB,EAAgC;AAC9B,UAAMF,EAAE,GAAGC,KAAK,CAACC,UAAD,CAAhB,CAD8B,CAE9B;;AACA,WAAOF,EAAE,IAAIV,GAAG,CAACa,IAAJ,CAAST,KAAT,EAAgBM,EAAhB,CAAN,GAA4BN,KAAK,CAACM,EAAD,CAAjC,GAAwC,IAA/C;AACD;AACF;AAED;AACA;AACA;AACA;;AACA,SAASC,KAAT,CAAeG,KAAf,EAAsB;AACpB,SAAOC,MAAM,CAACD,KAAK,IAAI,EAAV,CAAN,CAAoBE,WAApB,EAAP;AACD","sourcesContent":["/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Definition} Definition\n */\n\n/**\n * @typedef {Root | Content} Node\n *\n * @callback GetDefinition\n *   Get a definition by identifier.\n * @param {string | null | undefined} [identifier]\n *   Identifier of definition.\n * @returns {Definition | null}\n *   Definition corresponding to `identifier` or `null`.\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Find definitions in `tree`.\n *\n * Uses CommonMark precedence, which means that earlier definitions are\n * preferred over duplicate later definitions.\n *\n * @param {Node} tree\n *   Tree to check.\n * @returns {GetDefinition}\n *   Getter.\n */\nexport function definitions(tree) {\n  /** @type {Record<string, Definition>} */\n  const cache = Object.create(null)\n\n  if (!tree || !tree.type) {\n    throw new Error('mdast-util-definitions expected node')\n  }\n\n  visit(tree, 'definition', (definition) => {\n    const id = clean(definition.identifier)\n    if (id && !own.call(cache, id)) {\n      cache[id] = definition\n    }\n  })\n\n  return definition\n\n  /** @type {GetDefinition} */\n  function definition(identifier) {\n    const id = clean(identifier)\n    // To do: next major: return `undefined` when not found.\n    return id && own.call(cache, id) ? cache[id] : null\n  }\n}\n\n/**\n * @param {string | null | undefined} [value]\n * @returns {string}\n */\nfunction clean(value) {\n  return String(value || '').toUpperCase()\n}\n"]},"metadata":{},"sourceType":"module"}