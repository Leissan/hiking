{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''; // To do: next major, use `node.lang` w/o regex, the splitting’s been going\n  // on for years in remark now.\n\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null;\n  /** @type {Properties} */\n\n  const properties = {};\n\n  if (lang) {\n    properties.className = ['language-' + lang];\n  } // Create `<code>`.\n\n  /** @type {Element} */\n\n\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{\n      type: 'text',\n      value\n    }]\n  };\n\n  if (node.meta) {\n    result.data = {\n      meta: node.meta\n    };\n  }\n\n  state.patch(node, result);\n  result = state.applyData(node, result); // Create `<pre>`.\n\n  result = {\n    type: 'element',\n    tagName: 'pre',\n    properties: {},\n    children: [result]\n  };\n  state.patch(node, result);\n  return result;\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-to-hast/lib/handlers/code.js"],"names":["code","state","node","value","lang","match","properties","className","result","type","tagName","children","meta","data","patch","applyData"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,IAAT,CAAcC,KAAd,EAAqBC,IAArB,EAA2B;AAChC,QAAMC,KAAK,GAAGD,IAAI,CAACC,KAAL,GAAaD,IAAI,CAACC,KAAL,GAAa,IAA1B,GAAiC,EAA/C,CADgC,CAEhC;AACA;;AACA,QAAMC,IAAI,GAAGF,IAAI,CAACE,IAAL,GAAYF,IAAI,CAACE,IAAL,CAAUC,KAAV,CAAgB,qBAAhB,CAAZ,GAAqD,IAAlE;AACA;;AACA,QAAMC,UAAU,GAAG,EAAnB;;AAEA,MAAIF,IAAJ,EAAU;AACRE,IAAAA,UAAU,CAACC,SAAX,GAAuB,CAAC,cAAcH,IAAf,CAAvB;AACD,GAV+B,CAYhC;;AACA;;;AACA,MAAII,MAAM,GAAG;AACXC,IAAAA,IAAI,EAAE,SADK;AAEXC,IAAAA,OAAO,EAAE,MAFE;AAGXJ,IAAAA,UAHW;AAIXK,IAAAA,QAAQ,EAAE,CAAC;AAACF,MAAAA,IAAI,EAAE,MAAP;AAAeN,MAAAA;AAAf,KAAD;AAJC,GAAb;;AAOA,MAAID,IAAI,CAACU,IAAT,EAAe;AACbJ,IAAAA,MAAM,CAACK,IAAP,GAAc;AAACD,MAAAA,IAAI,EAAEV,IAAI,CAACU;AAAZ,KAAd;AACD;;AAEDX,EAAAA,KAAK,CAACa,KAAN,CAAYZ,IAAZ,EAAkBM,MAAlB;AACAA,EAAAA,MAAM,GAAGP,KAAK,CAACc,SAAN,CAAgBb,IAAhB,EAAsBM,MAAtB,CAAT,CA1BgC,CA4BhC;;AACAA,EAAAA,MAAM,GAAG;AAACC,IAAAA,IAAI,EAAE,SAAP;AAAkBC,IAAAA,OAAO,EAAE,KAA3B;AAAkCJ,IAAAA,UAAU,EAAE,EAA9C;AAAkDK,IAAAA,QAAQ,EAAE,CAACH,MAAD;AAA5D,GAAT;AACAP,EAAAA,KAAK,CAACa,KAAN,CAAYZ,IAAZ,EAAkBM,MAAlB;AACA,SAAOA,MAAP;AACD","sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n\n */\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  // To do: next major, use `node.lang` w/o regex, the splitting’s been going\n  // on for years in remark now.\n  const lang = node.lang ? node.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null\n  /** @type {Properties} */\n  const properties = {}\n\n  if (lang) {\n    properties.className = ['language-' + lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}