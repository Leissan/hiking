{"ast":null,"code":"/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */\nimport { visit } from 'unist-util-visit';\nimport { position, pointStart, pointEnd } from 'unist-util-position';\nimport { generated } from 'unist-util-generated';\nimport { definitions } from 'mdast-util-definitions';\nimport { handlers } from './handlers/index.js';\nconst own = {}.hasOwnProperty;\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {State}\n *   `state` function.\n */\n\nexport function createState(tree, options) {\n  const settings = options || {};\n  const dangerous = settings.allowDangerousHtml || false;\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n\n  const footnoteById = {}; // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n\n  state.dangerous = dangerous; // To do: next major: move to `state.options`.\n\n  state.clobberPrefix = settings.clobberPrefix === undefined || settings.clobberPrefix === null ? 'user-content-' : settings.clobberPrefix; // To do: next major: move to `state.options`.\n\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'; // To do: next major: move to `state.options`.\n\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'; // To do: next major: move to `state.options`.\n\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  }; // To do: next major: move to `state.options`.\n\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'; // To do: next major: move to `state.options`.\n\n  state.unknownHandler = settings.unknownHandler; // To do: next major: move to `state.options`.\n\n  state.passThrough = settings.passThrough;\n  state.handlers = { ...handlers,\n    ...settings.handlers\n  }; // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n\n  state.definition = definitions(tree);\n  state.footnoteById = footnoteById;\n  /** @type {Array<string>} */\n\n  state.footnoteOrder = [];\n  /** @type {Record<string, number>} */\n\n  state.footnoteCounts = {};\n  state.patch = patch;\n  state.applyData = applyData;\n  state.one = oneBound;\n  state.all = allBound;\n  state.wrap = wrap; // To do: next major: remove `augment`.\n\n  state.augment = augment;\n  visit(tree, 'footnoteDefinition', definition => {\n    const id = String(definition.identifier).toUpperCase(); // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition;\n    }\n  }); // @ts-expect-error Hush, it’s fine!\n\n  return state;\n  /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */\n\n  /* c8 ignore start */\n  // To do: next major: remove.\n\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data;\n\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          };\n        }\n\n        right.tagName = data.hName;\n      }\n\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = { ...right.properties,\n          ...data.hProperties\n        };\n      }\n\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren;\n      }\n    }\n\n    if (left) {\n      const ctx = 'type' in left ? left : {\n        position: left\n      };\n\n      if (!generated(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {\n          start: pointStart(ctx),\n          end: pointEnd(ctx)\n        };\n      }\n    }\n\n    return right;\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */\n\n  /* c8 ignore start */\n  // To do: next major: remove.\n\n\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props;\n      props = {};\n    } // @ts-expect-error augmenting an element yields an element.\n\n\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    });\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */\n\n\n  function oneBound(node, parent) {\n    // @ts-expect-error: that’s a state :)\n    return one(state, node, parent);\n  }\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n\n\n  function allBound(parent) {\n    // @ts-expect-error: that’s a state :)\n    return all(state, parent);\n  }\n}\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */\n\nfunction patch(from, to) {\n  if (from.position) to.position = position(from);\n}\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */\n\n\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to; // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n\n  if (from && from.data) {\n    const hName = from.data.hName;\n    const hChildren = from.data.hChildren;\n    const hProperties = from.data.hProperties;\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName;\n      } // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n          result = {\n            type: 'element',\n            tagName: hName,\n            properties: {},\n            children: []\n          }; // To do: next major: take the children from the `root`, or inject the\n          // raw/text/comment or so into the element?\n          // if ('children' in node) {\n          //   // @ts-expect-error: assume `children` are allowed in elements.\n          //   result.children = node.children\n          // } else {\n          //   // @ts-expect-error: assume `node` is allowed in elements.\n          //   result.children.push(node)\n          // }\n        }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      result.properties = { ...result.properties,\n        ...hProperties\n      };\n    }\n\n    if ('children' in result && result.children && hChildren !== null && hChildren !== undefined) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren;\n    }\n  }\n\n  return result;\n}\n/**\n * Transform an mdast node into a hast node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   mdast node.\n * @param {MdastParents | null | undefined} [parent]\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   Resulting hast node.\n */\n// To do: next major: do not expose, keep bound.\n\n\nexport function one(state, node, parent) {\n  const type = node && node.type; // Fail on non-nodes.\n\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent);\n  }\n\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? { ...node,\n      children: all(state, node)\n    } : node;\n  }\n\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent);\n  }\n\n  return defaultUnknownHandler(state, node);\n}\n/**\n * Transform the children of an mdast node into hast nodes.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} parent\n *   mdast node to compile\n * @returns {Array<HastElementContent>}\n *   Resulting hast nodes.\n */\n// To do: next major: do not expose, keep bound.\n\nexport function all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = [];\n\n  if ('children' in parent) {\n    const nodes = parent.children;\n    let index = -1;\n\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent); // To do: see if we van clean this? Can we merge texts?\n\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '');\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0];\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '');\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result);\n        } else {\n          values.push(result);\n        }\n      }\n    }\n  }\n\n  return values;\n}\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */\n\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {};\n  /** @type {HastText | HastElement} */\n\n  const result = 'value' in node && !(own.call(data, 'hProperties') || own.call(data, 'hChildren')) ? {\n    type: 'text',\n    value: node.value\n  } : {\n    type: 'element',\n    tagName: 'div',\n    properties: {},\n    children: all(state, node)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | null | undefined} [loose=false]\n *   Whether to add line endings at start and end.\n * @returns {Array<Type | HastText>}\n *   Wrapped nodes.\n */\n\n\nexport function wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = [];\n  let index = -1;\n\n  if (loose) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({\n      type: 'text',\n      value: '\\n'\n    });\n    result.push(nodes[index]);\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({\n      type: 'text',\n      value: '\\n'\n    });\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-to-hast/lib/state.js"],"names":["visit","position","pointStart","pointEnd","generated","definitions","handlers","own","hasOwnProperty","createState","tree","options","settings","dangerous","allowDangerousHtml","footnoteById","state","clobberPrefix","undefined","footnoteLabel","footnoteLabelTagName","footnoteLabelProperties","className","footnoteBackLabel","unknownHandler","passThrough","definition","footnoteOrder","footnoteCounts","patch","applyData","one","oneBound","all","allBound","wrap","augment","id","String","identifier","toUpperCase","call","left","right","data","hName","type","tagName","properties","children","hProperties","hChildren","ctx","start","end","node","props","Array","isArray","parent","from","to","result","Error","includes","defaultUnknownHandler","values","nodes","index","length","value","replace","head","push","loose"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAAQA,KAAR,QAAoB,kBAApB;AACA,SAAQC,QAAR,EAAkBC,UAAlB,EAA8BC,QAA9B,QAA6C,qBAA7C;AACA,SAAQC,SAAR,QAAwB,sBAAxB;AACA,SAAQC,WAAR,QAA0B,wBAA1B;AACA,SAAQC,QAAR,QAAuB,qBAAvB;AAEA,MAAMC,GAAG,GAAG,GAAGC,cAAf;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,OAA3B,EAAoC;AACzC,QAAMC,QAAQ,GAAGD,OAAO,IAAI,EAA5B;AACA,QAAME,SAAS,GAAGD,QAAQ,CAACE,kBAAT,IAA+B,KAAjD;AACA;;A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","sourcesContent":["/**\n * @typedef {import('hast').Content} HastContent\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Content} MdastContent\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Parent} MdastParent\n * @typedef {import('mdast').Root} MdastRoot\n */\n\n/**\n * @typedef {HastRoot | HastContent} HastNodes\n * @typedef {MdastRoot | MdastContent} MdastNodes\n * @typedef {Extract<MdastNodes, MdastParent>} MdastParents\n *\n * @typedef EmbeddedHastFields\n *   hast fields.\n * @property {string | null | undefined} [hName]\n *   Generate a specific element with this tag name instead.\n * @property {HastProperties | null | undefined} [hProperties]\n *   Generate an element with these properties instead.\n * @property {Array<HastElementContent> | null | undefined} [hChildren]\n *   Generate an element with this content instead.\n *\n * @typedef {Record<string, unknown> & EmbeddedHastFields} MdastData\n *   mdast data with embedded hast fields.\n *\n * @typedef {MdastNodes & {data?: MdastData | null | undefined}} MdastNodeWithData\n *   mdast node with embedded hast data.\n *\n * @typedef PointLike\n *   Point-like value.\n * @property {number | null | undefined} [line]\n *   Line.\n * @property {number | null | undefined} [column]\n *   Column.\n * @property {number | null | undefined} [offset]\n *   Offset.\n *\n * @typedef PositionLike\n *   Position-like value.\n * @property {PointLike | null | undefined} [start]\n *   Point-like value.\n * @property {PointLike | null | undefined} [end]\n *   Point-like value.\n *\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | null | undefined} parent\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   hast node.\n *\n * @callback HFunctionProps\n *   Signature of `state` for when props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {HastProperties} props\n *   Properties.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @callback HFunctionNoProps\n *   Signature of `state` for when no props are passed.\n * @param {MdastNodes | PositionLike | null | undefined} node\n *   mdast node or unist position.\n * @param {string} tagName\n *   HTML tag name.\n * @param {Array<HastElementContent> | null | undefined} [children]\n *   hast content.\n * @returns {HastElement}\n *   Compiled element.\n *\n * @typedef HFields\n *   Info on `state`.\n * @property {boolean} dangerous\n *   Whether HTML is allowed.\n * @property {string} clobberPrefix\n *   Prefix to use to prevent DOM clobbering.\n * @property {string} footnoteLabel\n *   Label to use to introduce the footnote section.\n * @property {string} footnoteLabelTagName\n *   HTML used for the footnote label.\n * @property {HastProperties} footnoteLabelProperties\n *   Properties on the HTML tag used for the footnote label.\n * @property {string} footnoteBackLabel\n *   Label to use from backreferences back to their footnote call.\n * @property {(identifier: string) => MdastDefinition | null} definition\n *   Definition cache.\n * @property {Record<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Record<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {Handler} unknownHandler\n *   Handler for any none not in `passThrough` or otherwise handled.\n * @property {(from: MdastNodes, node: HastNodes) => void} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => Type | HastElement} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {(node: MdastNodes, parent: MdastParents | null | undefined) => HastElementContent | Array<HastElementContent> | null | undefined} one\n *   Transform an mdast node to hast.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastContent>(nodes: Array<Type>, loose?: boolean | null | undefined) => Array<Type | HastText>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n * @property {(left: MdastNodeWithData | PositionLike | null | undefined, right: HastElementContent) => HastElementContent} augment\n *   Like `state` but lower-level and usable on non-elements.\n *   Deprecated: use `patch` and `applyData`.\n * @property {Array<string>} passThrough\n *   List of node types to pass through untouched (except for their children).\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree.\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` attribute on footnotes to prevent it from\n *   *clobbering*.\n * @property {string | null | undefined} [footnoteBackLabel='Back to content']\n *   Label to use from backreferences back to their footnote call (affects\n *   screen readers).\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Label to use for the footnotes section (affects screen readers).\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (note that `id: 'footnote-label'`\n *   is always added as footnote calls use it with `aria-describedby` to\n *   provide an accessible label).\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   Tag name to use for the footnote label.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes.\n * @property {Array<string> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes.\n *\n * @typedef {Record<string, Handler>} Handlers\n *   Handle nodes.\n *\n * @typedef {HFunctionProps & HFunctionNoProps & HFields} State\n *   Info passed around.\n */\n\nimport {visit} from 'unist-util-visit'\nimport {position, pointStart, pointEnd} from 'unist-util-position'\nimport {generated} from 'unist-util-generated'\nimport {definitions} from 'mdast-util-definitions'\nimport {handlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || {}\n  const dangerous = settings.allowDangerousHtml || false\n  /** @type {Record<string, MdastFootnoteDefinition>} */\n  const footnoteById = {}\n\n  // To do: next major: add `options` to state, remove:\n  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,\n  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,\n  // `unknownHandler`.\n\n  // To do: next major: move to `state.options.allowDangerousHtml`.\n  state.dangerous = dangerous\n  // To do: next major: move to `state.options`.\n  state.clobberPrefix =\n    settings.clobberPrefix === undefined || settings.clobberPrefix === null\n      ? 'user-content-'\n      : settings.clobberPrefix\n  // To do: next major: move to `state.options`.\n  state.footnoteLabel = settings.footnoteLabel || 'Footnotes'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2'\n  // To do: next major: move to `state.options`.\n  state.footnoteLabelProperties = settings.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  // To do: next major: move to `state.options`.\n  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content'\n  // To do: next major: move to `state.options`.\n  state.unknownHandler = settings.unknownHandler\n  // To do: next major: move to `state.options`.\n  state.passThrough = settings.passThrough\n\n  state.handlers = {...handlers, ...settings.handlers}\n\n  // To do: next major: replace utility with `definitionById` object, so we\n  // only walk once (as we need footnotes too).\n  state.definition = definitions(tree)\n  state.footnoteById = footnoteById\n  /** @type {Array<string>} */\n  state.footnoteOrder = []\n  /** @type {Record<string, number>} */\n  state.footnoteCounts = {}\n\n  state.patch = patch\n  state.applyData = applyData\n  state.one = oneBound\n  state.all = allBound\n  state.wrap = wrap\n  // To do: next major: remove `augment`.\n  state.augment = augment\n\n  visit(tree, 'footnoteDefinition', (definition) => {\n    const id = String(definition.identifier).toUpperCase()\n\n    // Mimick CM behavior of link definitions.\n    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.\n    if (!own.call(footnoteById, id)) {\n      footnoteById[id] = definition\n    }\n  })\n\n  // @ts-expect-error Hush, it’s fine!\n  return state\n\n  /**\n   * Finalise the created `right`, a hast node, from `left`, an mdast node.\n   *\n   * @param {MdastNodeWithData | PositionLike | null | undefined} left\n   * @param {HastElementContent} right\n   * @returns {HastElementContent}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function augment(left, right) {\n    // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n    if (left && 'data' in left && left.data) {\n      /** @type {MdastData} */\n      const data = left.data\n\n      if (data.hName) {\n        if (right.type !== 'element') {\n          right = {\n            type: 'element',\n            tagName: '',\n            properties: {},\n            children: []\n          }\n        }\n\n        right.tagName = data.hName\n      }\n\n      if (right.type === 'element' && data.hProperties) {\n        right.properties = {...right.properties, ...data.hProperties}\n      }\n\n      if ('children' in right && right.children && data.hChildren) {\n        right.children = data.hChildren\n      }\n    }\n\n    if (left) {\n      const ctx = 'type' in left ? left : {position: left}\n\n      if (!generated(ctx)) {\n        // @ts-expect-error: fine.\n        right.position = {start: pointStart(ctx), end: pointEnd(ctx)}\n      }\n    }\n\n    return right\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Create an element for `node`.\n   *\n   * @type {HFunctionProps}\n   */\n  /* c8 ignore start */\n  // To do: next major: remove.\n  function state(node, tagName, props, children) {\n    if (Array.isArray(props)) {\n      children = props\n      props = {}\n    }\n\n    // @ts-expect-error augmenting an element yields an element.\n    return augment(node, {\n      type: 'element',\n      tagName,\n      properties: props || {},\n      children: children || []\n    })\n  }\n  /* c8 ignore stop */\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | null | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n   *   Resulting hast node.\n   */\n  function oneBound(node, parent) {\n    // @ts-expect-error: that’s a state :)\n    return one(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function allBound(parent) {\n    // @ts-expect-error: that’s a state :)\n    return all(state, parent)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {void}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {Type | HastElement}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {Type | HastElement} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent is likely to keep the content around (otherwise: pass\n      // `hChildren`).\n      else {\n        result = {\n          type: 'element',\n          tagName: hName,\n          properties: {},\n          children: []\n        }\n\n        // To do: next major: take the children from the `root`, or inject the\n        // raw/text/comment or so into the element?\n        // if ('children' in node) {\n        //   // @ts-expect-error: assume `children` are allowed in elements.\n        //   result.children = node.children\n        // } else {\n        //   // @ts-expect-error: assume `node` is allowed in elements.\n        //   result.children.push(node)\n        // }\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      result.properties = {...result.properties, ...hProperties}\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      // @ts-expect-error: assume valid children are defined.\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an mdast node into a hast node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   mdast node.\n * @param {MdastParents | null | undefined} [parent]\n *   Parent of `node`.\n * @returns {HastElementContent | Array<HastElementContent> | null | undefined}\n *   Resulting hast node.\n */\n// To do: next major: do not expose, keep bound.\nexport function one(state, node, parent) {\n  const type = node && node.type\n\n  // Fail on non-nodes.\n  if (!type) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n\n  if (own.call(state.handlers, type)) {\n    return state.handlers[type](state, node, parent)\n  }\n\n  if (state.passThrough && state.passThrough.includes(type)) {\n    // To do: next major: deep clone.\n    // @ts-expect-error: types of passed through nodes are expected to be added manually.\n    return 'children' in node ? {...node, children: all(state, node)} : node\n  }\n\n  if (state.unknownHandler) {\n    return state.unknownHandler(state, node, parent)\n  }\n\n  return defaultUnknownHandler(state, node)\n}\n\n/**\n * Transform the children of an mdast node into hast nodes.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} parent\n *   mdast node to compile\n * @returns {Array<HastElementContent>}\n *   Resulting hast nodes.\n */\n// To do: next major: do not expose, keep bound.\nexport function all(state, parent) {\n  /** @type {Array<HastElementContent>} */\n  const values = []\n\n  if ('children' in parent) {\n    const nodes = parent.children\n    let index = -1\n    while (++index < nodes.length) {\n      const result = one(state, nodes[index], parent)\n\n      // To do: see if we van clean this? Can we merge texts?\n      if (result) {\n        if (index && nodes[index - 1].type === 'break') {\n          if (!Array.isArray(result) && result.type === 'text') {\n            result.value = result.value.replace(/^\\s+/, '')\n          }\n\n          if (!Array.isArray(result) && result.type === 'element') {\n            const head = result.children[0]\n\n            if (head && head.type === 'text') {\n              head.value = head.value.replace(/^\\s+/, '')\n            }\n          }\n        }\n\n        if (Array.isArray(result)) {\n          values.push(...result)\n        } else {\n          values.push(result)\n        }\n      }\n    }\n  }\n\n  return values\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastText | HastElement}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastText | HastElement} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: all(state, node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | null | undefined} [loose=false]\n *   Whether to add line endings at start and end.\n * @returns {Array<Type | HastText>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<Type | HastText>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n"]},"metadata":{},"sourceType":"module"}