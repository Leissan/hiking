{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n/**\n * @type {(\n *   (() => false) &\n *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n * )}\n */\n\n/**\n * @param {unknown} [node]\n * @param {Test} [test]\n * @param {number | null | undefined} [index]\n * @param {Parent | null | undefined} [parent]\n * @param {unknown} [context]\n * @returns {boolean}\n */\n// eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n  const check = convert(test);\n\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  } // @ts-expect-error Looks like a node.\n\n\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\n};\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\n\nexport const convert =\n/**\n * @type {(\n *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n *   ((test?: Test) => AssertAnything)\n * )}\n */\n\n/**\n * @param {Test} [test]\n * @returns {AssertAnything}\n */\nfunction (test) {\n  if (test === undefined || test === null) {\n    return ok;\n  }\n\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n\n  throw new Error('Expected function, string, or object as test');\n};\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\n\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = [];\n  let index = -1;\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n\n  return castFactory(any);\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function any(...parameters) {\n    let index = -1;\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true;\n    }\n\n    return false;\n  }\n}\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\n\n\nfunction propsFactory(check) {\n  return castFactory(all);\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n\n  function all(node) {\n    /** @type {string} */\n    let key;\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false;\n    }\n\n    return true;\n  }\n}\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\n\n\nfunction typeFactory(check) {\n  return castFactory(type);\n  /**\n   * @param {Node} node\n   */\n\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\n\n\nfunction castFactory(check) {\n  return assertion;\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n\n  function assertion(node, ...parameters) {\n    return Boolean(node && typeof node === 'object' && 'type' in node && // @ts-expect-error: fine.\n    Boolean(check.call(this, node, ...parameters)));\n  }\n}\n\nfunction ok() {\n  return true;\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/react-markdown/node_modules/unist-util-is/lib/index.js"],"names":["is","node","test","index","parent","context","check","convert","undefined","Number","POSITIVE_INFINITY","Error","children","type","Boolean","call","ok","typeFactory","Array","isArray","anyFactory","propsFactory","castFactory","tests","checks","length","any","parameters","all","key","assertion"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMA,EAAE;AACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA,SAASA,EAAT,CAAYC,IAAZ,EAAkBC,IAAlB,EAAwBC,KAAxB,EAA+BC,MAA/B,EAAuCC,OAAvC,EAAgD;AAC9C,QAAMC,KAAK,GAAGC,OAAO,CAACL,IAAD,CAArB;;AAEA,MACEC,KAAK,KAAKK,SAAV,IACAL,KAAK,KAAK,IADV,KAEC,OAAOA,KAAP,KAAiB,QAAjB,IACCA,KAAK,GAAG,CADT,IAECA,KAAK,KAAKM,MAAM,CAACC,iBAJnB,CADF,EAME;AACA,UAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,MACEP,MAAM,KAAKI,SAAX,IACAJ,MAAM,KAAK,IADX,KAEC,CAACJ,EAAE,CAACI,MAAD,CAAH,IAAe,CAACA,MAAM,CAACQ,QAFxB,CADF,EAIE;AACA,UAAM,IAAID,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,MACE,CAACP,MAAM,KAAKI,SAAX,IAAwBJ,MAAM,KAAK,IAApC,OACCD,KAAK,KAAKK,SAAV,IAAuBL,KAAK,KAAK,IADlC,CADF,EAGE;AACA,UAAM,IAAIQ,KAAJ,CAAU,gCAAV,CAAN;AACD,GA1B6C,CA4B9C;;;AACA,SA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","sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n */\n\n/**\n * @typedef {Record<string, unknown>} Props\n * @typedef {null | undefined | string | Props | TestFunctionAnything | Array<string | Props | TestFunctionAnything>} Test\n *   Check for an arbitrary node, unaware of TypeScript inferral.\n *\n * @callback TestFunctionAnything\n *   Check if a node passes a test, unaware of TypeScript inferral.\n * @param {unknown} this\n *   The given context.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean | void}\n *   Whether this node passes the test.\n */\n\n/**\n * @template {Node} Kind\n *   Node type.\n * @typedef {Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind> | Array<Kind['type'] | Partial<Kind> | TestFunctionPredicate<Kind>>} PredicateTest\n *   Check for a node that can be inferred by TypeScript.\n */\n\n/**\n * Check if a node passes a certain test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback TestFunctionPredicate\n *   Complex test function for a node that can be inferred by TypeScript.\n * @param {Node} node\n *   A node.\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this node passes the test.\n */\n\n/**\n * @callback AssertAnything\n *   Check that an arbitrary value is a node, unaware of TypeScript inferral.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {boolean}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if a node is a node and passes a certain node test.\n *\n * @template {Node} Kind\n *   Node type.\n * @callback AssertPredicate\n *   Check that an arbitrary value is a specific node, aware of TypeScript.\n * @param {unknown} [node]\n *   Anything (typically a node).\n * @param {number | null | undefined} [index]\n *   The node’s position in its parent.\n * @param {Parent | null | undefined} [parent]\n *   The node’s parent.\n * @returns {node is Kind}\n *   Whether this is a node and passes a test.\n */\n\n/**\n * Check if `node` is a `Node` and whether it passes the given test.\n *\n * @param node\n *   Thing to check, typically `Node`.\n * @param test\n *   A check for a specific node.\n * @param index\n *   The node’s position in its parent.\n * @param parent\n *   The node’s parent.\n * @returns\n *   Whether `node` is a node and passes a test.\n */\nexport const is =\n  /**\n   * @type {(\n   *   (() => false) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index: number, parent: Parent, context?: unknown) => node is Kind) &\n   *   (<Kind extends Node = Node>(node: unknown, test: PredicateTest<Kind>, index?: null | undefined, parent?: null | undefined, context?: unknown) => node is Kind) &\n   *   ((node: unknown, test: Test, index: number, parent: Parent, context?: unknown) => boolean) &\n   *   ((node: unknown, test?: Test, index?: null | undefined, parent?: null | undefined, context?: unknown) => boolean)\n   * )}\n   */\n  (\n    /**\n     * @param {unknown} [node]\n     * @param {Test} [test]\n     * @param {number | null | undefined} [index]\n     * @param {Parent | null | undefined} [parent]\n     * @param {unknown} [context]\n     * @returns {boolean}\n     */\n    // eslint-disable-next-line max-params\n    function is(node, test, index, parent, context) {\n      const check = convert(test)\n\n      if (\n        index !== undefined &&\n        index !== null &&\n        (typeof index !== 'number' ||\n          index < 0 ||\n          index === Number.POSITIVE_INFINITY)\n      ) {\n        throw new Error('Expected positive finite index')\n      }\n\n      if (\n        parent !== undefined &&\n        parent !== null &&\n        (!is(parent) || !parent.children)\n      ) {\n        throw new Error('Expected parent node')\n      }\n\n      if (\n        (parent === undefined || parent === null) !==\n        (index === undefined || index === null)\n      ) {\n        throw new Error('Expected both parent and index')\n      }\n\n      // @ts-expect-error Looks like a node.\n      return node && node.type && typeof node.type === 'string'\n        ? Boolean(check.call(context, node, index, parent))\n        : false\n    }\n  )\n\n/**\n * Generate an assertion from a test.\n *\n * Useful if you’re going to test many nodes, for example when creating a\n * utility where something else passes a compatible test.\n *\n * The created function is a bit faster because it expects valid input only:\n * a `node`, `index`, and `parent`.\n *\n * @param test\n *   *   when nullish, checks if `node` is a `Node`.\n *   *   when `string`, works like passing `(node) => node.type === test`.\n *   *   when `function` checks if function passed the node is true.\n *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\n *   *   when `array`, checks if any one of the subtests pass.\n * @returns\n *   An assertion.\n */\nexport const convert =\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  (\n    /**\n     * @param {Test} [test]\n     * @returns {AssertAnything}\n     */\n    function (test) {\n      if (test === undefined || test === null) {\n        return ok\n      }\n\n      if (typeof test === 'string') {\n        return typeFactory(test)\n      }\n\n      if (typeof test === 'object') {\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\n      }\n\n      if (typeof test === 'function') {\n        return castFactory(test)\n      }\n\n      throw new Error('Expected function, string, or object as test')\n    }\n  )\n\n/**\n * @param {Array<string | Props | TestFunctionAnything>} tests\n * @returns {AssertAnything}\n */\nfunction anyFactory(tests) {\n  /** @type {Array<AssertAnything>} */\n  const checks = []\n  let index = -1\n\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index])\n  }\n\n  return castFactory(any)\n\n  /**\n   * @this {unknown}\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function any(...parameters) {\n    let index = -1\n\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true\n    }\n\n    return false\n  }\n}\n\n/**\n * Turn an object into a test for a node with a certain fields.\n *\n * @param {Props} check\n * @returns {AssertAnything}\n */\nfunction propsFactory(check) {\n  return castFactory(all)\n\n  /**\n   * @param {Node} node\n   * @returns {boolean}\n   */\n  function all(node) {\n    /** @type {string} */\n    let key\n\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false\n    }\n\n    return true\n  }\n}\n\n/**\n * Turn a string into a test for a node with a certain type.\n *\n * @param {string} check\n * @returns {AssertAnything}\n */\nfunction typeFactory(check) {\n  return castFactory(type)\n\n  /**\n   * @param {Node} node\n   */\n  function type(node) {\n    return node && node.type === check\n  }\n}\n\n/**\n * Turn a custom test into a test for a node that passes that test.\n *\n * @param {TestFunctionAnything} check\n * @returns {AssertAnything}\n */\nfunction castFactory(check) {\n  return assertion\n\n  /**\n   * @this {unknown}\n   * @param {unknown} node\n   * @param {Array<unknown>} parameters\n   * @returns {boolean}\n   */\n  function assertion(node, ...parameters) {\n    return Boolean(\n      node &&\n        typeof node === 'object' &&\n        'type' in node &&\n        // @ts-expect-error: fine.\n        Boolean(check.call(this, node, ...parameters))\n    )\n  }\n}\n\nfunction ok() {\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}