{"ast":null,"code":"/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\nimport { pointStart, pointEnd } from 'unist-util-position';\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\n\nexport function table(state, node) {\n  const rows = state.all(node);\n  const firstRow = rows.shift();\n  /** @type {Array<Element>} */\n\n  const tableContent = [];\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    };\n    state.patch(node.children[0], head);\n    tableContent.push(head);\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    };\n    const start = pointStart(node.children[1]);\n    const end = pointEnd(node.children[node.children.length - 1]);\n    if (start.line && end.line) body.position = {\n      start,\n      end\n    };\n    tableContent.push(body);\n  }\n  /** @type {Element} */\n\n\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-to-hast/lib/handlers/table.js"],"names":["pointStart","pointEnd","table","state","node","rows","all","firstRow","shift","tableContent","head","type","tagName","properties","children","wrap","patch","push","length","body","start","end","line","position","result","applyData"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,SAAQA,UAAR,EAAoBC,QAApB,QAAmC,qBAAnC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,KAAT,CAAeC,KAAf,EAAsBC,IAAtB,EAA4B;AACjC,QAAMC,IAAI,GAAGF,KAAK,CAACG,GAAN,CAAUF,IAAV,CAAb;AACA,QAAMG,QAAQ,GAAGF,IAAI,CAACG,KAAL,EAAjB;AACA;;AACA,QAAMC,YAAY,GAAG,EAArB;;AAEA,MAAIF,QAAJ,EAAc;AACZ;AACA,UAAMG,IAAI,GAAG;AACXC,MAAAA,IAAI,EAAE,SADK;AAEXC,MAAAA,OAAO,EAAE,OAFE;AAGXC,MAAAA,UAAU,EAAE,EAHD;AAIXC,MAAAA,QAAQ,EAAEX,KAAK,CAACY,IAAN,CAAW,CAACR,QAAD,CAAX,EAAuB,IAAvB;AAJC,KAAb;AAMAJ,IAAAA,KAAK,CAACa,KAAN,CAAYZ,IAAI,CAACU,QAAL,CAAc,CAAd,CAAZ,EAA8BJ,IAA9B;AACAD,IAAAA,YAAY,CAACQ,IAAb,CAAkBP,IAAlB;AACD;;AAED,MAAIL,IAAI,CAACa,MAAL,GAAc,CAAlB,EAAqB;AACnB;AACA,UAAMC,IAAI,GAAG;AACXR,MAAAA,IAAI,EAAE,SADK;AAEXC,MAAAA,OAAO,EAAE,OAFE;AAGXC,MAAAA,UAAU,EAAE,EAHD;AAIXC,MAAAA,QAAQ,EAAEX,KAAK,CAACY,IAAN,CAAWV,IAAX,EAAiB,IAAjB;AAJC,KAAb;AAOA,UAAMe,KAAK,GAAGpB,UAAU,CAACI,IAAI,CAACU,QAAL,CAAc,CAAd,CAAD,CAAxB;AACA,UAAMO,GAAG,GAAGpB,QAAQ,CAACG,IAAI,CAACU,QAAL,CAAcV,IAAI,CAACU,QAAL,CAAcI,MAAd,GAAuB,CAArC,CAAD,CAApB;AACA,QAAIE,KAAK,CAACE,IAAN,IAAcD,GAAG,CAACC,IAAtB,EAA4BH,IAAI,CAACI,QAAL,GAAgB;AAACH,MAAAA,KAAD;AAAQC,MAAAA;AAAR,KAAhB;AAC5BZ,IAAAA,YAAY,CAACQ,IAAb,CAAkBE,IAAlB;AACD;AAED;;;AACA,QAAMK,MAAM,GAAG;AACbb,IAAAA,IAAI,EAAE,SADO;AAEbC,IAAAA,OAAO,EAAE,OAFI;AAGbC,IAAAA,UAAU,EAAE,EAHC;AAIbC,IAAAA,QAAQ,EAAEX,KAAK,CAACY,IAAN,CAAWN,YAAX,EAAyB,IAAzB;AAJG,GAAf;AAMAN,EAAAA,KAAK,CAACa,KAAN,CAAYZ,IAAZ,EAAkBoB,MAAlB;AACA,SAAOrB,KAAK,CAACsB,SAAN,CAAgBrB,IAAhB,EAAsBoB,MAAtB,CAAP;AACD","sourcesContent":["/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointStart, pointEnd} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start.line && end.line) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n"]},"metadata":{},"sourceType":"module"}