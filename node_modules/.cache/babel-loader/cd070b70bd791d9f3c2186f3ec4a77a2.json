{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined; // Generate a body row when without parent.\n\n  const rowIndex = siblings ? siblings.indexOf(node) : 1;\n  const tagName = rowIndex === 0 ? 'th' : 'td';\n  const align = parent && parent.type === 'table' ? parent.align : undefined;\n  const length = align ? align.length : node.children.length;\n  let cellIndex = -1;\n  /** @type {Array<ElementContent>} */\n\n  const cells = [];\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex];\n    /** @type {Properties} */\n\n    const properties = {};\n    const alignValue = align ? align[cellIndex] : undefined;\n\n    if (alignValue) {\n      properties.align = alignValue;\n    }\n    /** @type {Element} */\n\n\n    let result = {\n      type: 'element',\n      tagName,\n      properties,\n      children: []\n    };\n\n    if (cell) {\n      result.children = state.all(cell);\n      state.patch(cell, result);\n      result = state.applyData(node, result);\n    }\n\n    cells.push(result);\n  }\n  /** @type {Element} */\n\n\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  };\n  state.patch(node, result);\n  return state.applyData(node, result);\n}","map":{"version":3,"sources":["/home/leissan/Development/hiking/client/node_modules/mdast-util-to-hast/lib/handlers/table-row.js"],"names":["tableRow","state","node","parent","siblings","children","undefined","rowIndex","indexOf","tagName","align","type","length","cellIndex","cells","cell","properties","alignValue","result","all","patch","applyData","push","wrap"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,QAAT,CAAkBC,KAAlB,EAAyBC,IAAzB,EAA+BC,MAA/B,EAAuC;AAC5C,QAAMC,QAAQ,GAAGD,MAAM,GAAGA,MAAM,CAACE,QAAV,GAAqBC,SAA5C,CAD4C,CAE5C;;AACA,QAAMC,QAAQ,GAAGH,QAAQ,GAAGA,QAAQ,CAACI,OAAT,CAAiBN,IAAjB,CAAH,GAA4B,CAArD;AACA,QAAMO,OAAO,GAAGF,QAAQ,KAAK,CAAb,GAAiB,IAAjB,GAAwB,IAAxC;AACA,QAAMG,KAAK,GAAGP,MAAM,IAAIA,MAAM,CAACQ,IAAP,KAAgB,OAA1B,GAAoCR,MAAM,CAACO,KAA3C,GAAmDJ,SAAjE;AACA,QAAMM,MAAM,GAAGF,KAAK,GAAGA,KAAK,CAACE,MAAT,GAAkBV,IAAI,CAACG,QAAL,CAAcO,MAApD;AACA,MAAIC,SAAS,GAAG,CAAC,CAAjB;AACA;;AACA,QAAMC,KAAK,GAAG,EAAd;;AAEA,SAAO,EAAED,SAAF,GAAcD,MAArB,EAA6B;AAC3B;AACA,UAAMG,IAAI,GAAGb,IAAI,CAACG,QAAL,CAAcQ,SAAd,CAAb;AACA;;AACA,UAAMG,UAAU,GAAG,EAAnB;AACA,UAAMC,UAAU,GAAGP,KAAK,GAAGA,KAAK,CAACG,SAAD,CAAR,GAAsBP,SAA9C;;AAEA,QAAIW,UAAJ,EAAgB;AACdD,MAAAA,UAAU,CAACN,KAAX,GAAmBO,UAAnB;AACD;AAED;;;AACA,QAAIC,MAAM,GAAG;AAACP,MAAAA,IAAI,EAAE,SAAP;AAAkBF,MAAAA,OAAlB;AAA2BO,MAAAA,UAA3B;AAAuCX,MAAAA,QAAQ,EAAE;AAAjD,KAAb;;AAEA,QAAIU,IAAJ,EAAU;AACRG,MAAAA,MAAM,CAACb,QAAP,GAAkBJ,KAAK,CAACkB,GAAN,CAAUJ,IAAV,CAAlB;AACAd,MAAAA,KAAK,CAACmB,KAAN,CAAYL,IAAZ,EAAkBG,MAAlB;AACAA,MAAAA,MAAM,GAAGjB,KAAK,CAACoB,SAAN,CAAgBnB,IAAhB,EAAsBgB,MAAtB,CAAT;AACD;;AAEDJ,IAAAA,KAAK,CAACQ,IAAN,CAAWJ,MAAX;AACD;AAED;;;AACA,QAAMA,MAAM,GAAG;AACbP,IAAAA,IAAI,EAAE,SADO;AAEbF,IAAAA,OAAO,EAAE,IAFI;AAGbO,IAAAA,UAAU,EAAE,EAHC;AAIbX,IAAAA,QAAQ,EAAEJ,KAAK,CAACsB,IAAN,CAAWT,KAAX,EAAkB,IAAlB;AAJG,GAAf;AAMAb,EAAAA,KAAK,CAACmB,KAAN,CAAYlB,IAAZ,EAAkBgB,MAAlB;AACA,SAAOjB,KAAK,CAACoB,SAAN,CAAgBnB,IAAhB,EAAsBgB,MAAtB,CAAP;AACD","sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('mdast').Content} Content\n * @typedef {import('mdast').Parent} Parent\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n/**\n * @typedef {Root | Content} Nodes\n * @typedef {Extract<Nodes, Parent>} Parents\n */\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | null | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(node, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n"]},"metadata":{},"sourceType":"module"}